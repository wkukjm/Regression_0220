# -*- coding: utf-8 -*-
"""02.18_linear_regression_diabet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F7TgRfZFN0Tc66n-AkO6cd4w9-dvX1Kz
"""

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import Sequential, Input
from tensorflow.keras.layers import Dense

from sklearn.datasets import load_diabetes
dataset = load_diabetes()
'''
dataBunch
    data{ndarray, dataframe} of shape (442, 10),  pandas DataFrame.
    target: {ndarray, Series} of shape (442,), pandas Series.
    feature_names: list, dataset columns.
    frame: DataFrame of shape (442, 11)
'''
print(dataset.keys())
print(dataset["data"].shape)
x_data = dataset["data"]
print(x_data[0])
print(dataset["feature_names"])
#속성 정보:
# 나이(연령) 성별 BMI(체질량지수) bp(평균 혈압) s1 tc, 총 혈청 콜레스테롤
# s2 ldl, 저밀도 지단백질 s3 hdl, 고밀도 지단백질 s4 tch, 총 콜레스테롤/HDL
# s5 ltg, 혈청 트리글리세리드 수치의 로그일 수 있음 s6 glu, 혈당 수치
y_data = dataset["target"] # y_data의 수치가 높을수록 당뇨일 확률이 높아진다.
print("1년후 질량 수치의 평균:",f"{np.mean(y_data):.2f}",
      "1년후 질량 수치의 최저값:",f"{np.min(y_data):.2f}",
      "1년후 질량 수치의 최대값:",f"{np.max(y_data):.2f}")
print(np.max(y_data))
#print(dataset["DESCR"])

#최종 데이터 모양 출력
print(x_data.shape)
print(y_data.shape)

#연관분석 scatter
for i in range(10):
  plt.scatter(x_data[:,i],y_data)
  plt.title(f"dataindex:{i}")
  plt.show();

x_train = x_data[:,[2,8]]
y_train = y_data
print(x_train.shape)
print(y_train.shape)
#x_train = x_train.reshape((len(x_train),1))
print(x_train.shape)
print(x_train[0])
print(y_train[0])

model = Sequential()
model.add(Input((2,)))
model.add(Dense(1))
model.compile(loss="MSE",optimizer="SGD",metrics=["mse"])

fhist = model.fit(x_train,y_train,epochs=13)

print(fhist.history.keys())
plt.plot(fhist.history["mse"])
plt.show()

#테스팅 데이터 추출
x_test = x_train[:10]
y_test = y_train[:10]
print(x_test.shape)
print(y_test.shape)

y_pred = model.predict(x_test)
y_true_sum=0
y_pred_sum=0
for ix in range(len(y_test)):
  y_true_sum+=y_test[ix]
  y_pred_sum+=y_pred[ix]
gap = y_true_sum-y_pred_sum
err_rat = gap/y_true_sum*100
print("모델의 오차확률은 ± %.2f"%(err_rat))

